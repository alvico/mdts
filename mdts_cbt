#!/bin/bash -xe

if [ ".$WORKSPACE" == "." ]; then
    WORKSPACE=$( cd `dirname ${BASH_SOURCE[0]}`/../.. ; pwd)
fi

# Defaults which can be modified via command line args
SOURCE_OR_PACKAGE="source"
SOURCE_REPO="midonet/midonet"
SOURCE_BRANCH="master"
SOURCE_DIR="$WORKSPACE/midonet_source"
GIT_SERVER="github.com"
GIT_SSH=false
GIT_SSH_USER=
GIT_CREDENTIALS=
REPO_URI="http://repo.midonet.org/midonet/current"
REPO_CURL_URI="http://repo.midonet.org/packages.midokura.key"
REPO_DIST="unstable"
#ART_URI="ssh://ci-jenkins@artifactory-dev.bcn.midokura.com/artifactory/midonet"
#ART_CURL_URI="http://artifactory-dev.bcn.midokura.com/artifactory/api/gpg/key/public"
ART_URI="http://artifactory-dev.bcn.midokura.com/artifactory/midonet"
ART_CURL_URI="http://artifactory-dev.bcn.midokura.com/artifactory/api/gpg/key/public"
#ART_URI="http://bcn4.bcn.midokura.com:8081/artifactory/midonet"
#ART_CURL_URI="http://bcn4.bcn.midokura.com:8081/artifactory/api/gpg/key/public"
ART_DIST="nightly"
PKG_COMP="main"
LOCAL_TEST="true"
TESTS_TO_RUN=
TESTS_TO_EXCLUDE=

# Defaults for internal vars
TEST_ROOT=$( cd `dirname ${BASH_SOURCE[0]}` ; pwd)
INSTALL_ENV=true
INSTALL_PKG=true
FETCH_SOURCE=true
BUILD_SOURCE=true
RUN_TESTS="true"
PKG_URI=
PKG_DIST=
TARGET=
NO_RUN=false
ECHO=
CLEAN_CMD=

# Helper Functions
function usage()
{
    set +x
    if [ ".$1" != "." ]; then
	echo "Error: $1"
    fi
    echo "Usage: mdts_cbt [opts] git <repo> <branch> [-gs <server>] [-ssh]"
    echo "       mdts_cbt [opts] (source|file) <source_dir>"
    echo "       mdts_cbt [opts] (package|artifactory) <uri> <component>"
    echo "       mdts_cbt [opts] (stop|clean)"
    echo " "
    echo " General Options (opts):"
    echo "       -tr <dir>               Sets the test root to <dir> (defaults to WS/mdts/tests)"
    echo "       -t <tests>              Tests to run against the specified target in quotes (defaults"
    echo "                               to 'test_bridge' only)"
    echo "       -x <tests>              Tests to exclude in run against the specified target in quotes" 
    echo "       -r                      Test from remote test server (like jenkins) on a fresh VM host"
    echo "                               (versus local machine)"
    echo "       -ne                     Do not install base system environment"
    echo "       -nt                     Do not run tests, only fetch/build/install MN"
    echo "       -n                      Dry run: print commands that would be run but don't proceed"
    echo " Targets: (must specify one and only one):"
    echo "    Pull MN from git repository:"
    echo "       git <repo> <branch>     Test against MidoNet found in git repo <repo> on <branch>. "
    echo "       Options:"
    echo "          -git-server <srv>    Set the GIT hub server to use for source (default is github.com)"
    echo "          -git-ssh <user>      Use SSH to connect to GIT server as <user>"
    echo "          -ni                  Do not install MN packages after building source"
    echo "    Pull MN from packages on disk:"
    echo "       source <dir>            Test against packages waiting on disk in <dir>"
    echo "       Options:"
    echo "          -ni                  Do not install MN packages after building source"
    echo "    Pull MN from packages on disk:"
    echo "       file <dir>              Test against packages waiting on disk in <dir>"
    echo "    Pull MN from apt-get repository:"
    echo "       package <uri> <dst>     Test against MidoNet <item> repository located at <uri>"
    echo "    Pull MN from artifactory repository:"
    echo "       artifactory <uri> <dst> Test against MidoNet <item> artifactory product located at <uri>"
    echo "    Cleanup currently running test system:"
    echo "       stop                    Shutdown the MDTS system"
    echo "       clean                   Stops MDTS and uninstalls MidoNet packages"
}

function check_and_set()
{
    VAR=$1
    shift
    if [ $# -eq 0 ]; then 
	return 1
    fi

    if printf '%s' $1 | grep -q "^-"; then
	return 1
    fi

    eval $VAR=$1
    return 0
}

function clean_target()
{
    TEST_ROOT_DIR=$1
    shift
    case $1 in
	"process")
	    $ECHO cd $TEST_ROOT_DIR/mmm/scripts
	    $ECHO sudo ./stop && true
	    $ECHO sudo ./shutdown && true
	    $ECHO sudo update-rc.d midolman disable && true
	    ;;
	"mdts")
	    $ECHO sudo dpkg -P midolman midonet-api python-midonetclient && true
	    ;;
	"conf")
	    $ECHO sudo rm -rf /etc/zookeeper.*
	    $ECHO sudo rm -rf /etc/quagga.*
	    $ECHO sudo rm -rf /etc/cassandra.*
	    $ECHO sudo rm -rf /etc/midolman.*
	    $ECHO sudo rm -rf /etc/quagga.*
	    ;;
	"logs")
	    $ECHO sudo rm -rf /var/log/zookeeper.*
	    $ECHO sudo rm -rf /var/log/quagga.*
	    $ECHO sudo rm -rf /var/log/cassandra.*
	    $ECHO sudo rm -rf /var/log/midolman.*
	    $ECHO sudo rm -rf /var/log/quagga.*
	    $ECHO sudo rm -rf /var/log/tomcat7/*
	    ;;
	"libs")
	    $ECHO sudo rm -rf /var/lib/zookeeper.*
	    $ECHO sudo rm -rf /var/lib/quagga.*
	    $ECHO sudo rm -rf /var/lib/cassandra.*
	    $ECHO sudo rm -rf /var/lib/midolman.*
	    $ECHO sudo rm -rf /var/lib/quagga.*
	    ;;
	*)
	    ;;
    esac
}

function clean()
{
    if [ ".$1" == "." ]; then
	    clean_target process
    else
	while [ ".$1" != "." ]; do
	    if [ ".$1" == ".all" ]; then
		for i in process mdts conf logs libs; do
		    clean_target $i
		done
	    elif [ ".$1" == ".files" ]; then
		for i in conf logs libs; do
		    clean_target $i
		done
	    elif [ ".$1" == "." ]; then
		clean_target process
	    else
		clean_target $1
	    fi
	    shift
	done
    fi

}


function fetch_source_from_git()
{
    DIR=$1
    SERVER=$2
    REPO=$3
    BRANCH=$4
    SSH=$5
    SSH_USER=$6
    
    $ECHO rm -rf $DIR
    if [ ".$SSH" == ".true" ]; then
	GIT_CX=$SSH_USER@$SERVER:$REPO 
    else
	GIT_CX=http://$SERVER/$REPO 
    fi
    echo "Fetching source code from $GIT_CX -b $BRANCH into dir: $DIR"
    $ECHO git clone $GIT_CX -b $BRANCH $DIR
}


function build_source_from_dir {
    DIR=$1

    echo "Will build source from $DIR"
    $ECHO cd $DIR
    
    $ECHO export LD_LIBRARY_PATH=".:/lib:/usr/lib:/usr/local/lib:./lib"
    
    $ECHO git submodule update --init --recursive
    
    # Build midonet source
    $ECHO ./gradlew -x test debian
}

function install_package_from_dir {
    DIR=$1

    echo "Installing midonet packages from all *.deb files in $DIR"
    $ECHO cd $DIR

    for package in `find . -name *.deb`
    do
	$ECHO sudo dpkg --force-confold -i $package
    done
}

function remove_mn_packages {
    # CLean pre-installed midolman if present
    if [[ `dpkg -l | grep -q midolman` -eq 0 ]]; then
	clean mdts && true
    fi
}	

function install_package_from_repo {
    URI=$1
    DIST=$2
    COMP=$3
    CURI=$4
    echo "Installing midonet from pre-built packages at $1 $2 $3"

    # add midokura sources to apt
    $ECHO sudo bash -c "echo deb [arch=all] $URI $DIST $COMP > /etc/apt/sources.list.d/midokura-midonet.list"
    $ECHO curl -k $CURI | sudo apt-key add - && true

    artifactory_user=ci-jenkins
    artifactory_password=AP3WkR7bsSRcv3B81WaVqmvta5a

    $ECHO sudo apt-get update
    
    # Install midolman
    $ECHO sudo apt-get install -y --force-yes midolman
    $ECHO sudo update-rc.d midolman enable
    
    $ECHO sudo apt-get install -y --force-yes python-midonetclient
    $ECHO sudo apt-get -o Dpkg::Options::="--force-confnew" install -y --force-yes midonet-api
}

function print_config_check() {
    NEG="will NOT"
    if [ ".$1" == .$2 ]; then
	NEG="WILL"
    fi
    shift 2
    echo "We $NEG $@"
}

function print_config {
    set +x
    echo target=$TARGET
    echo install_env=$INSTALL_ENV
    echo git_server=$GIT_SERVER
    echo git_use_ssh=$GIT_SSH
    echo git_ssh_user=$GIT_SSH_USER
    echo git_credentials=$GIT_CREDENTIALS
    echo file_location=$FILE_LOCATION
    echo source_branch=$SOURCE_BRANCH
    echo source_repo=$SOURCE_REPO
    echo install_package=$INSTALL_PKG
    echo pkg_uri=$PKG_URI
    echo curl_uri=$CURL_URI
    echo pkg_distribution=$PKG_DIST
    echo pkg_component=$PKG_COMP
    echo test_root=$TEST_ROOT
    echo tests_to_run=$TESTS_TO_RUN
    echo tests_exclude=$TESTS_TO_EXCLUDE
    echo workspace=$WORKSPACE
    echo clean_target=$CLEAN_CMD

    print_config_check $INSTALL_ENV true "install and setup base environment"
    case $TARGET in
	git|source)
	    print_config_check $TARGET "git" "fetch MN source from git"
	    print_config_check true true "build MN source"
	    print_config_check $INSTALL_PKG true "install MN packages"
	    ;;
	file )
	    print_config_check true false "fetch MN source from git"
	    print_config_check true false "build MN source"
	    print_config_check true true "install MN packages"
	    ;;
	package )
	    print_config_check true true "fetch MN packages from APT-GET repository"
	    ;;
	artifactory )
	    print_config_check true true "fetch MN packages from Artifactory"
	    ;;
    esac
    print_config_check $RUN_TESTS true "run MDTS functional tests"

    set -x
}


#MAIN

while [ ".$1" != "." ]; do
    case $1 in
	# Cleaning and Stopping the system
	"stop" | --stop )
	    CLEAN_CMD="process"
	    shift
	    ;;

	"clean" | --clean )
	    CLEAN_CMD="process mdts"
	    shift
	    ;;

	"cleanall" | --clean-all )
	    CLEAN_CMD="all"
	    shift
	    ;;

	"cleanconfig" | --clean-config )
	    CLEAN_CMD="process files"
	    shift
	    ;;

	# Behavior flags
	-n | --no-run )
	    NO_RUN="true"
	    shift
	    ;;

	-r | --remote )
	    LOCAL_TEST="false"
	    shift
	    ;;

	-ne | --no-env-install )
	    INSTALL_ENV="false"
	    shift
	    ;;

	-ni | --no-install )
	    INSTALL_PKG="false"
	    shift
	    ;;

	-nt | --no-tests )
	    RUN_TESTS="false"
	    shift
	    ;;

	# Test setup
	-tr | --test-root )
	    shift
	    if ! check_and_set TEST_ROOT $*; then
		usage "Invalid directory for test_root: $1"
		exit 1
	    fi
	    shift
	    ;;

        -t | --test )
	    shift
	    while check_and_set TESTS_TO_RUN $*; do
		TESTS_LINE="$TESTS_LINE -t $TESTS_TO_RUN"
		shift
	    done
            ;;

        -x | --exclude )
	    shift
	    while check_and_set TESTS_TO_EXCLUDE $*; do
		EXCLUDE_LINE="$EXCLUDE_LINE -e $TESTS_TO_EXCLUDE"
		shift
	    done
            ;;

	# Build and Test target (file, packages, source, etc.)
        "git" | --git )
	    if [ ".$TARGET" != "." ]; then
		usage "Specified more than one MN target"
		exit 1
	    fi
	    TARGET=git
	    shift
	    check_and_set SOURCE_REPO $* && shift
	    check_and_set SOURCE_BRANCH $* && shift
            ;;

        "source" | --source )
	    if [ ".$TARGET" != "." ]; then
		usage "Specified more than one MN target"
		exit 1
	    fi
	    TARGET=source
	    shift
	    check_and_set SOURCE_DIR $* && shift
            ;;

	"file" | --file )
	    if [ ".$TARGET" != "." ]; then
		usage "Specified more than one MN target"
		exit 1
	    fi
	    TARGET=file
	    shift
	    check_and_set SOURCE_DIR $* && shift
	    ;;

        "package" | --package )
	    if [ ".$TARGET" != "." ]; then
		usage "Specified more than one MN target"
		exit 1
	    fi
	    TARGET=package
	    CURL_URI=$REPO_CURL_URI
	    PKG_URI=$REPO_URI
	    PKG_DIST=$REPO_DIST
	    shift
	    check_and_set PKG_URI $* && shift
	    check_and_set PKG_DIST $* && shift
            ;;

        "artifactory" | --artifactory )
	    if [ ".$TARGET" != "." ]; then
		usage "Specified more than one MN target"
		exit 1
	    fi
	    TARGET=artifactory
	    CURL_URI=$ART_CURL_URI
	    PKG_URI=$ART_URI
	    PKG_DIST=$ART_DIST
	    shift
	    check_and_set PKG_URI $* && shift
	    check_and_set PKG_DIST $* && shift
            ;;

	# Extra flags to tweak GIT bheavior
	-git-server | --git-server )
	    shift
	    if ! check_and_set GIT_SERVER $*; then
		usage "Invalid GIT server: $1"
		exit 1
	    fi
	    shift
            ;;

	-git-cred | --git-credentials )
	    shift
	    if ! check_and_set GIT_CREDENTIALS $*; then
		usage "Invalid GIT credentials: $1"
		exit 1
	    fi
	    shift
            ;;

	-git-ssh | --git-ssh )
	    shift
	    if ! check_and_set GIT_SSH_USER $*; then
		usage "Invalid GIT ssh user: $1"
		exit 1
	    fi
	    GIT_SSH=true
	    shift
	    ;;

	# Help
        -h | --help )
            usage
            exit
            ;;

	# Catch-all
        * )
	    usage "'$1' is not a valid option or parameter"
	    exit 1
	    ;;
    esac
done

if [ ".$CLEAN_CMD" == "." -a ".$TARGET" == "." ]; then
    usage "Must specify CBT target: git, source, file, package, artifactory; or a clean target: stop, clean, cleanconfig, cleanall"
    exit 1
fi

echo "IP interfaces: "
ifconfig | grep -A1 'encap:Ethernet' | grep -v "\-\-" | awk '/Ethernet / { printf "%s: ", $1 } /inet / { print $2 }' | sed 's/addr://g'

echo "Executing the script as: "
whoami

echo "Executing at time: "
date

print_config

# Set up echo to spit out commands instead of running them if dry-run is set
if [ ".$NO_RUN" == ".true" ]; then
    ECHO="echo"
    set +x
fi

# If there's a clean command, just run it and exit
if [ ".$CLEAN_CMD" != "." ]; then
    clean $TEST_ROOT $CLEAN_CMD
    exit 
fi

# Remote (i.e. jenkins) test tweaks for speed
if [ ".$LOCAL_TEST" == ".false" ]; then
    # Mounting ramdisks
    sudo cp -RL --preserve=all /var/lib /tmp/
    sudo mkdir /var/lib
    sudo mount -t tmpfs -o size=1024m tmpfs /var/lib
    sudo cp -RL --preserve=all /tmp/lib/* /var/lib/
    sudo cp -RL --preserve=all /var/log /tmp/
    sudo mkdir /var/log
    sudo mount -t tmpfs -o size=256m tmpfs /var/log
    sudo cp -RL --preserve=all /tmp/log/* /var/log
fi

$ECHO cd $TEST_ROOT

#Set up the test server with all the tools we'll need to test MidoNet
if [ ".$INSTALL_ENV" == ".true" ]; then
    $ECHO ./setup_test_server $TEST_ROOT
fi


# git = Source from GIT, fetch, build and install
# source = Source on disk, build and install
# file = Package on disk, install
# package = Package on standard apt-get repo, fetch and install
# artifactory = Package on artifactory apt-get repo, fetch and install

case $TARGET in
    "git")
	fetch_source_from_git $SOURCE_DIR $GIT_SERVER $SOURCE_REPO $SOURCE_BRANCH $GIT_SSH $GIT_SSH_USER
	build_source_from_dir $SOURCE_DIR
	if [ ".$INSTALL_PKG" == ".true" ]; then
	    install_package_from_dir $SOURCE_DIR
	fi
	;;
    "source")
	build_source_from_dir $SOURCE_DIR
	if [ ".$INSTALL_PKG" == ".true" ]; then
	    install_package_from_dir $SOURCE_DIR
	fi
	;;
    "file")
	remove_mn_packages
	install_package_from_dir $SOURCE_DIR
	;;
    "package"|"artifactory")
	remove_mn_packages
	install_package_from_repo $PKG_URI $PKG_DIST $PKG_COMP $CURL_URI
	;;
esac

if [ ".$RUN_TESTS" == ".false" ]; then
    exit
fi

echo "Tests are in $TEST_ROOT (will create if needed)"
$ECHO cd $TEST_ROOT/mmm
# all mmm init
$ECHO sudo ./init

$ECHO cd scripts
$ECHO sudo ./boot
$ECHO sudo ./start

# Wait for all midolman hosts
if [ ".$NO_RUN" == ".false" ]; then
    RETRIES=30
    CONNECTED=false
    while [ $CONNECTED == "false" ]; do
	if [ `midonet-cli --midonet-url http://localhost:8080/midonet-api -A -e "host list" | wc -l` -eq 3 ]; then
	    CONNECTED=true
	elif [ $RETRIES -eq 0 ]; then
	    echo "Midolman hosts failed to start.  Midonet-API host list:"
	    midonet-cli --midonet-url http://localhost:8080/midonet-api -A -e "host list"
	    exit 1
	else
	    (( RETRIES-- ))
	    sleep 5
	fi
    done
fi

$ECHO cd $TEST_ROOT/mdts/tests/functional_tests

# exclude bgp and l2gw tests (bgp and l2gw tests are executed in separate jobs)
$ECHO ./run_tests.sh $TESTS_LINE $EXCLUDE_LINE


